# 데이터 정의의 우선순위: 타입(Type)인가, 스펙(Spec)인가?

현대적인 웹 애플리케이션 개발에서 `데이터`는 시스템의 혈액과 같습니다. API 서버는 데이터를 가공해 저장하거나 응답하고, 클라이언트는 이를 받아 사용자에게 시각적으로 전달합니다. 이 과정에서 우리는 데이터를 정의하기 위해 타입, 스키마, 스펙 등 다양한 도구를 사용합니다. 과연 무엇을 최우선(First)으로 두어야 견고한 시스템을 구축할 수 있을까요?

## 1. 문제 제기: 설계도와 실제 자재 사이의 괴리

애플리케이션이 복잡해질수록 데이터를 정의하는 방식은 파편화됩니다. API 명세서, DB 스키마, 프론트엔드 타입 정의가 제각각 놀기 시작하면 '데이터 불일치'라는 치명적인 문제가 발생합니다.

단순히 "데이터가 다양하다"는 사실보다 더 무서운 것은 **"컴파일 타임의 설계도(Type)와 런타임에 흐르는 실제 데이터(Value) 사이의 간극"**입니다. 설계도는 완벽해 보이는데, 막상 실행해 보니 예상치 못한 데이터가 들어와 시스템이 터지는 경험은 모든 개발자의 숙명과도 같습니다. 이를 해결하기 위해 우리는 더 강력한 데이터 정의 수단이 필요합니다.

## 2. 타입 정의의 한계: '형태'는 알지만 '내용'은 모른다

많은 개발자가 TypeScript 인터페이스로 데이터를 정의하며 안심합니다. 하지만 TypeScript의 타입 시스템은 **런타임에 사라지는 정적 분석 도구**일 뿐입니다.

- **Loose Typing의 위험:** `string` 타입은 "이것은 문자열이다"라고 말할 뿐, 이메일 형식인지, 최소 10자 이상인지, 특수문자가 포함되었는지 보장하지 못합니다.
- **방어적 코드의 양산:** 타입만으로는 부족하기 때문에, 결국 코드 곳곳에 `if (!data) return;` 이나 `if (data.length > 100) ...` 같은 유효성 검사 로직이 파편화되어 흩어지게 됩니다.
- **오염된 데이터에 대한 무방비:** 외부 API나 DB에서 들어오는 데이터는 컴파일 타임의 타입 체크를 거치지 않습니다. "타입은 안전한데 값은 엉망인" 상태가 지속되는 것입니다.

## 3. 스키마와 스펙: Zod vs JSON Schema

이러한 한계를 극복하기 위해 '스키마(Schema)' 기반의 검증 도구를 도입해야 합니다. 가장 대표적인 두 주자인 **Zod**와 **JSON Schema**를 비교해 보겠습니다.

### **Zod: 개발자 경험(DX)과 코드 친숙도**

Zod는 TypeScript 중심의 **Code-first** 접근 방식을 취합니다.

- **장점:** `.refine()`을 통한 커텀 검증, 데이터 변환(Parsing), 그리고 무엇보다 작성한 스키마에서 TypeScript 타입을 즉시 추출(`z.infer`)할 수 있다는 강력함이 있습니다.
- **단점:** TS/JS 생태계에 종속적입니다. 만약 백엔드가 Go나 Java이고 프론트가 TS라면, 이 스키마를 공유하기 어렵습니다.

### **JSON Schema: 언어 중립성과 표준 스펙**

JSON Schema는 데이터 구조를 JSON으로 정의하는 **Spec-first** 방식입니다.

- **장점:** 언어에 독립적입니다. `$ref`를 통해 로컬이나 원격의 스키마를 참조할 수 있어, 거대한 시스템의 '표준 계약서' 역할을 수행하기에 최적입니다.
- **단점:** JSON 형식 특성상 동적인 로직(다른 필드 참조 검증 등)을 작성하기 매우 복잡하며, 사람이 읽고 쓰기에 장황(Verbose)합니다.

| 비교 항목 | Zod (Code-first) | JSON Schema (Spec-first) |
| :- | :-: | :-: |
| **작성 편의성** | 매우 높음 (TS 친화적) | 낮음 (복잡한 JSON 구조) |
| **런타임 검증** | 매우 강력 (Transform 지원) | 기본 검증 위주 |
| **언어 범용성** | JS/TS 환경에 국한 | 모든 언어 표준 지원 |

## 4. 결론: Single Source of Truth를 향하여

결국 중요한 것은 **"단일 진실 공급원(Single Source of Truth, SSOT)"**을 구축하는 것입니다. 어떤 도구를 선택하든 다음의 전략을 권장합니다.

1. **Parse, don't validate:** 단순히 데이터가 맞는지 확인만 하지 말고, 검증된 데이터를 안전한 타입으로 변환(Parsing)하여 시스템 내부로 흘려보내야 합니다.
2. **Schema to Type:** 스키마를 먼저 정의하고, 거기서 타입을 추출(Inference)하십시오. 수동으로 인터페이스를 따로 만들지 마세요. 중복 정의는 곧 버그의 온상입니다.
3. **생태계 결합:** Drizzle ORM이나 TypeORM 같은 도구와 스키마 검증 도구를 연동하세요. DB 스키마가 곧 API 스펙이 되고, 이것이 곧 프론트엔드의 타입이 되는 **End-to-End Type Safety**를 구축할 때 시스템의 신뢰성은 극대화됩니다.

우리는 이제 단순한 '타입 선언'을 넘어, 시스템 전체를 관통하는 '살아있는 스펙'을 설계해야 합니다. 그것이 높은 신뢰성을 가진 시스템을 구축하는 가장 빠른 길입니다.
