# [기술 제안] 전 구간 가시성 확보를 위한 CID(Correlation ID) 통합 전략 및 자립형 추적 체계 구축

## **기: 문제 제기 (The Challenge)**

시스템의 복잡도가 증가할수록 단일 요청의 생애 주기를 추적하는 것은 장애 대응의 핵심이 됩니다. 하지만 현재 많은 웹 아키텍처는 다음과 같은 **추적의 단절(Observability Gap)**을 겪고 있습니다.

* **구간별 식별자 부재:** 프레임워크 수준의 `Request-ID`는 서버 내부에서 생성됩니다. 이로 인해 Client와 Nginx(Proxy) 사이의 로그를 연결할 공통 식별자가 사라집니다.
* **데이터베이스 쿼리 연관성 결여:** API 엔드포인트와 실제 실행된 SQL 간의 연결 고리가 없어, DB 부하 발생 시 어떤 API가 범인인지 즉각 판별할 수 없습니다.

## **승: 문제 원인 (Root Cause)**

1. **생성 시점의 지연:** 식별자가 시스템의 최외곽(Client)이 아닌 서버 깊숙한 곳에서 부여되기 때문에 이전 단계 로그는 '익명' 상태가 됩니다.
2. **ORM 추상화와 'Final Query'의 부재:** TypeORM, Prisma 등은 로그에 `?` 형태의 Prepared Statement를 남깁니다. 실제 값이 바인딩된 쿼리는 DB 서버에만 존재하므로, 애플리케이션 로그만으로는 디버깅이 어렵습니다.
3. **상용 도구의 비용 리스크:** Datadog, AWS X-Ray 등은 트래픽당 과금 구조를 가져 기업 규모가 커질수록 유지 비용이 서버 비용을 상회하게 됩니다.

## **전: 연구 요약 및 기술적 대안 (Proposed Solution)**

### **1. 추적 메커니즘 흐름**

### **2. CID 전달 전략: GET Parameter vs Custom Header**

CID를 전달하는 방식에는 두 가지 선택지가 있으며, 각각의 장단점이 명확합니다.

* **GET Parameter (`?cid=UUID`) 방식 (우선 권장):**
* **장점:** 별도의 Nginx 설정 변경 없이도 대부분의 웹 서버와 프록시의 기본 **Access Log**에 자동으로 기록됩니다. 도입이 매우 빠르고 간편합니다.
* **단점:** URL에 식별자가 노출되므로 보안 정책에 따라 민감하게 받아들여질 수 있습니다.

* **Custom Header (`X-Correlation-ID`) 방식:**
* **장점:** URL에 노출되지 않아 보안상 더 안전하며 깔끔합니다.
* **주의사항:** Nginx 등 프록시 서버는 기본적으로 커스텀 헤더를 로그에 남기지 않습니다. 이 방식을 채택할 경우 **반드시 Nginx의 `log_format` 설정을 변경**하여 해당 헤더를 로깅하도록 작업해야 합니다.

### **3. 기술 선택 및 구현 (UUID v4 vs v7)**

| 항목 | UUID v4 | UUID v7 (강력 추천) |
| - | - | - |
| **특징** | 완전 무작위 | **Unix Timestamp** 기반 정렬 가능 |
| **DB 성능** | 인덱스 파편화 발생 가능성 | 시간순 정렬로 B-Tree 인덱스 최적화 |

* **JavaScript 구현:**

```javascript
import { v7 as uuidv7 } from 'uuid';
const cid = uuidv7(); // 시간 순 정렬 가능한 식별자 생성

```

### **4. 상용 도구 및 Sentry 비교**

* **Datadog/X-Ray:** 성능 가시성은 좋으나 비용 문제가 있습니다. 이 문서의 방법은 비용은 없지만 개발 비용이 추가 됩니다. 전체적인 비용을 비교했을 때 아키텍처나 서버 규모가 커질 수록 비용 차이가 커집니다.
* **Sentry.io:** 에러 스냅샷 도구입니다. CID 전략은 정상 요청을 포함한 **전체 경로 지도**를 그리는 것이므로 Sentry와 상호 보완 관계입니다.

### **5. DB 레벨 로깅의 중요성 (MySQL)**

애플리케이션 로그는 `WHERE id = ?`를 기록하지만, DB의 **General Log**는 실제 값이 채워진 **Final Query**를 기록합니다. 쿼리 끝에 `/*cid: UUID*/` 주석을 실행하면 ORM의 추상화에 속지 않고 실제 DB 부하 원인을 정확히 특정할 수 있습니다.

* **MySQL 설정:** `SET GLOBAL general_log = 'ON';`, `SET GLOBAL log_output = 'TABLE';`

## **결: 결론 및 기대효과 (Conclusion & Benefits)**

1. **지속 가능한 비용 구조:** 트래픽 폭증 시에도 모니터링 비용이 늘지 않아 대규모 환경에서 가장 현실적이고 경제적인 대안입니다.
2. **완벽한 전 구간 가시성:** Client → Nginx → Application → Database로 이어지는 모든 로그가 CID 하나로 통합되어 MTTR(평균 복구 시간)을 획기적으로 단축합니다.
3. **디버깅 효율 극대화:** DB가 "실제로 받은 쿼리"를 CID로 추적함으로써, ORM 뒤에 숨은 성능 저하를 명확하게 밝혀냅니다.
4. **플랫폼 독립적 아키텍처:** 특정 언어나 SaaS 벤더에 종속되지 않아 인프라 변경 시에도 동일한 추적 정책을 유지할 수 있는 강력한 무기가 됩니다.
